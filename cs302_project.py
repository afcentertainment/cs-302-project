# -*- coding: utf-8 -*-
"""CS302 project.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1aYgmuxrGH0uKq5H1MCa4QTKnaGvbrDSa

# class Needleman-Wunsch
"""

class NeedlemanWunsch:
    def __init__(self, seq1, seq2, match_score=1, mismatch_score=-1, gap_penalty=-2):
        self.seq1 = seq1
        self.seq2 = seq2
        self.match_score = match_score
        self.mismatch_score = mismatch_score
        self.gap_penalty = gap_penalty

    def initialize_matrix(self):
        rows, cols = len(self.seq1) + 1, len(self.seq2) + 1
        matrix = [[0 for _ in range(cols)] for _ in range(rows)]

        for i in range(rows):
            matrix[i][0] = i * self.gap_penalty
        for j in range(cols):
            matrix[0][j] = j * self.gap_penalty
        return matrix

    def fill_matrix(self, matrix):
        for i in range(1, len(matrix)):
            for j in range(1, len(matrix[0])):
                if self.seq1[i - 1] == self.seq2[j - 1]:
                    match = matrix[i - 1][j - 1] + self.match_score
                else:
                    match = matrix[i - 1][j - 1] + self.mismatch_score

                gap1 = matrix[i - 1][j] + self.gap_penalty
                gap2 = matrix[i][j - 1] + self.gap_penalty

                matrix[i][j] = max(match, gap1, gap2)

    def traceback(self, matrix):
        alignment1, alignment2 = [], []
        i, j = len(self.seq1), len(self.seq2)

        while i > 0 and j > 0:
            current_score = matrix[i][j]
            diagonal_score = matrix[i - 1][j - 1]
            left_score = matrix[i][j - 1]
            up_score = matrix[i - 1][j]

            if current_score == diagonal_score + (self.match_score if self.seq1[i - 1] == self.seq2[j - 1] else self.mismatch_score):
                alignment1.append(self.seq1[i - 1])
                alignment2.append(self.seq2[j - 1])
                i -= 1
                j -= 1
            elif current_score == up_score + self.gap_penalty:
                alignment1.append(self.seq1[i - 1])
                alignment2.append('-')
                i -= 1
            else:
                alignment1.append('-')
                alignment2.append(self.seq2[j - 1])
                j -= 1

        while i > 0:
            alignment1.append(self.seq1[i - 1])
            alignment2.append('-')
            i -= 1

        while j > 0:
            alignment1.append('-')
            alignment2.append(self.seq2[j - 1])
            j -= 1

        alignment1.reverse()
        alignment2.reverse()

        return ''.join(alignment1), ''.join(alignment2)

    def align(self):
        matrix = self.initialize_matrix()
        self.fill_matrix(matrix)
        alignment1, alignment2 = self.traceback(matrix)
        return alignment1, alignment2, matrix[-1][-1]

"""#  [Example from slides](https://docs.google.com/presentation/d/1u1Lq-i9D-KusnBxiCsASh7ZJi1ngJ2Kb1VQpCFwNzxM/edit?usp=sharing)"""

#default scoring scheme
match_score=1
mismatch_score=-1
gap_penalty=-2

#pass input sequences here
seq1 = "ATGCT"
seq2 = "AGCT"

nw = NeedlemanWunsch(seq1, seq2, match_score, mismatch_score, gap_penalty)  # Create NeedlemanWunsch object
alignment1, alignment2, score = nw.align()

print("The given sequences are: ")
print(f"Sequence 1: {seq1}")
print(f"Sequence 2: {seq2}\n")
print("Needleman-Wunsch Alignment Results")
print(f"Sequence 1: {alignment1}")
print(f"Sequence 2: {alignment2}")
print(f"Alignment Score: {score}")

"""# import libraries for time analysis & test case generating purpose only

---


"""

import matplotlib.pyplot as plt
import random
import time

"""# Same or Variable length Sequence Generator"""

class SequenceGenerator:
    def __init__(self, length):
        self.length = length

    def generate_random_sequence(self,length):
        # Generate a random sequence of letters (A, C, G, T) of the specified length.
        return ''.join(random.choice("ACGT") for _ in range(length))

    def generate_test_case_same_len(self):
        # Generate two random sequences of the given length.
        seq1 = self.generate_random_sequence(self.length)
        seq2 = self.generate_random_sequence(self.length)
        return seq1, seq2

    def generate_test_case_var_len(self):
        # Generate two random sequences of the different length between [1,passed parameter].
        random_len1=random.randint(1,self.length)
        random_len2=random.randint(1,self.length)
        seq1 = self.generate_random_sequence(random_len1)
        seq2 = self.generate_random_sequence(random_len2)
        return seq1, seq2

"""# Execution Time vs Sequence Length Analysis"""

def plot(execution_times,sequence_lengths):
  plt.figure(figsize=(8, 6))
  plt.plot(execution_times, sequence_lengths, marker='o', linestyle='-')
  plt.title('Execution Time vs Sequence Length')
  plt.xlabel('Execution Time in seconds')
  plt.ylabel('Sequence Length')
  plt.grid(True)
  plt.show()

"""# main function for implementing code with execution time"""

def main(same_length=1):
    test_case_lengths = [i for i in range(10,500,50)]  # Specify different sequence lengths
    match_score = 1
    mismatch_score = -2
    gap_penalty = -4
    execution_times=[]
    sequence_lengths=[]
    for length in test_case_lengths:
        generator = SequenceGenerator(length)
        if same_length==1:
          seq1, seq2 = generator.generate_test_case_same_len() # for same length random sequences creation
        else:
          seq1, seq2 = generator.generate_test_case_var_len()   # for variable length random sequences creation


        # Measure execution time
        start_time = time.time()
        nw = NeedlemanWunsch(seq1, seq2, match_score, mismatch_score, gap_penalty)
        alignment1, alignment2, score = nw.align()
        end_time = time.time()
        execution_time = end_time - start_time
        execution_times.append(execution_time)
        sequence_lengths.append(length)
        print("The given sequences are: ")
        print(f"Sequence 1: {seq1}")
        print(f"Sequence 1 Length: {len(seq1)}")
        print(f"Sequence 2: {seq2}")
        print(f"Sequence 2 Length: {len(seq2)}\n")
        print("Aligned Sequence 1:", alignment1)
        print("Aligned Sequence 2:", alignment2)
        print("Alignment Score:", score)
        print(f"Execution Time: {round(execution_time, 2)} seconds\n")
        print("-" * 50)
    return execution_times,sequence_lengths

"""# Run the code"""

if __name__ == "__main__":
    execution_times,sequence_lengths = main(1) # pass 1 for same lenght sequence and else for variable length
    plot(execution_times,sequence_lengths)

